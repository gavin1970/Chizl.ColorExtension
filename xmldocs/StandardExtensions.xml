<?xml version="1.0" encoding="utf-8"?>
<extradoc>
  <class name="StandardExtensions">
    <returns />
    <methods>
      <method name="Name">
        <summary>Returns the 'string' name of the Enums value being used. &lt;br/&gt;  &lt;code&gt;
         Example:
             var e = MyEnum.Property
             Console.WriteLine($"Enum property name: {e.Name()}");
         &lt;/code&gt;</summary>
        <returns>string name of enum property</returns>
      </method>
      <method name="Value">
        <summary>Returns the 'int' value of the Enums value being used. &lt;br/&gt;  &lt;code&gt;
         Example:
             var e = MyEnum.Property
             Console.WriteLine($"Enum property value: {e.Value()}");
         &lt;/code&gt;</summary>
        <returns>int value of enum property</returns>
      </method>
      <method name="SetBoundary">
        <summary>Responds with numeric value passed in after forcing value to be within range given from Min to Max. &lt;br/&gt;  If less than Min, Min will be the set value. &lt;br/&gt;  If more than Max, Max will be the set value.</summary>
        <returns>value forced within range.</returns>
        <params>
          <param name="min">
            <summary>Minimum value allowed</summary>
          </param>
          <param name="max">
            <summary>Maximum value allowed</summary>
          </param>
          <param name="decCount">
            <summary>(Range (0-4): Rounds to specific decimal. &lt;br/&gt; /// If the decCount value isn't passed in, is less than 0, or more than 4: Default: 0)</summary>
          </param>
        </params>
      </method>
      <method name="ClampTo">
        <summary>Since netstandard2.0 doesn't have Math.Clamp, this will do it.</summary>
        <returns>Forced bounds value based on type</returns>
        <params>
          <param name="value">
            <summary>this var</summary>
          </param>
          <param name="min">
            <summary>Miniumum value based on type</summary>
          </param>
          <param name="max">
            <summary>Maximum value based on type</summary>
          </param>
        </params>
      </method>
      <method name="IsHex">
        <summary>Uses Regex to validate if string as a whole is HexV8, HexV6, or HexV3, allowing # to be optional. &lt;br/&gt;  Pattern: "^([#]?([a-fA-F0-9]{8})|([a-fA-F0-9]{6})|([a-fA-F0-9]{3}))$"</summary>
        <returns>(bool) &lt;br/&gt;  - true : is HEX &lt;br/&gt;  - false: is not HEX</returns>
      </method>
      <method name="IsNumeric">
        <summary>&lt;code&gt;
         Verifies if a string is numerica, which includes negatives and deciamals.
         Pattern: @"^\-?\d{1,10}(\.\d{1,8})?$"
         Allows: 1.0, 1234567890, -1234567890, 1234567890.12345678, -1234567890.12345678, -0.12345678
         --------------------------------------------------
         [\-]?            : Optional negative
         [\d]{1,10}       : Required Digit only. Legnth: Min 1, Max 10
         (                : Starting optional group 1
             [\.]         : Required decimal
             [\d]{1,8}    : Required Digit only. Legnth: Min 1, Max 8
         )?               : End optional group 1
         Required: Numeric Only [0-9] {Minlength 1, MaxLength: 10}
         Optional Decimal: If exists( [.][0-9] {Minlength 1, MaxLength: 8} )
         &lt;/code&gt;</summary>
        <returns></returns>
      </method>
      <method name="RemoveAsciiEscape">
        <summary>Removes all Ascii Escape Character for colors and font styling.</summary>
        <returns></returns>
      </method>
      <method name="IsSupportedNumeric">
        <summary></summary>
        <returns></returns>
      </method>
    </methods>
  </class>
</extradoc>